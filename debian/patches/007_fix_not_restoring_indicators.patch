From d9957814176c81b6e1e22e8faf266ab9504b3c4a Mon Sep 17 00:00:00 2001
From: Luiz Augusto von Dentz <luiz.dentz-von@nokia.com>
Date: Thu, 10 Feb 2011 17:21:58 -0800
Subject: [PATCH 2/3 v2] Fix not resetting indicators whenever the driver is initialized

This may cause invalid values to be reported since the status of call can
change during the time adaptor was off.
---
 audio/telephony-maemo6.c |    9 +++++++++
 1 files changed, 9 insertions(+), 0 deletions(-)

diff --git a/audio/telephony-maemo6.c b/audio/telephony-maemo6.c
index 0c99c34..86405fc 100644
--- a/audio/telephony-maemo6.c
+++ b/audio/telephony-maemo6.c
@@ -1950,6 +1950,7 @@ int telephony_init(void)
 				AG_FEATURE_ENHANCED_CALL_CONTROL |
 				AG_FEATURE_EXTENDED_ERROR_RESULT_CODES |
 				AG_FEATURE_THREE_WAY_CALLING;
+	int i;
 
 	DBG("");
 
@@ -1981,6 +1982,14 @@ int telephony_init(void)
 	DBG("telephony-maemo6 registering %s interface on path %s",
 			TELEPHONY_MAEMO_INTERFACE, TELEPHONY_MAEMO_PATH);
 
+	/* Reset indicators */
+	for (i = 0; maemo_indicators[i].desc != NULL; i++) {
+		if (g_str_equal(maemo_indicators[i].desc, "battchg"))
+			maemo_indicators[i].val = 5;
+		else
+			maemo_indicators[i].val = 0;
+	}
+
 	telephony_ready_ind(features, maemo_indicators, BTRH_NOT_SUPPORTED,
 								chld_str);
 	if (send_method_call("org.freedesktop.Hal",
-- 
1.7.1

From b7314d494eacb3258195a61218cbadc1e234fd9c Mon Sep 17 00:00:00 2001
From: Luiz Augusto von Dentz <luiz.dentz-von@nokia.com>
Date: Fri, 11 Feb 2011 09:02:59 -0800
Subject: [PATCH 3/3] Fix not updating call indicator when parsing call info reply

This can happen if there is a call with a status different than idle when
adaptor is turned on the call indicators weren't updated.
---
 audio/telephony-maemo6.c |   63 ++++++++++++++++++++++++++-------------------
 1 files changed, 36 insertions(+), 27 deletions(-)

diff --git a/audio/telephony-maemo6.c b/audio/telephony-maemo6.c
index 86405fc..dfa06d9 100644
--- a/audio/telephony-maemo6.c
+++ b/audio/telephony-maemo6.c
@@ -973,35 +973,13 @@ static void handle_create_requested(DBusMessage *msg)
 					EV_CALLSETUP_OUTGOING);
 }
 
-static void handle_call_status(DBusMessage *msg, const char *call_path)
+static void call_set_status(struct csd_call *call, dbus_uint32_t status)
 {
-	struct csd_call *call;
-	dbus_uint32_t status, cause_type, cause, prev_status;
+	dbus_uint32_t prev_status;
 	int callheld = telephony_get_indicator(maemo_indicators, "callheld");
 
-	if (!dbus_message_get_args(msg, NULL,
-					DBUS_TYPE_UINT32, &status,
-					DBUS_TYPE_UINT32, &cause_type,
-					DBUS_TYPE_UINT32, &cause,
-					DBUS_TYPE_INVALID)) {
-		error("Unexpected paramters in Instance.CallStatus() signal");
-		return;
-	}
-
-	call = find_call(call_path);
-	if (!call) {
-		error("Didn't find any matching call object for %s",
-				call_path);
-		return;
-	}
-
-	if (status > 16) {
-		error("Invalid call status %u", status);
-		return;
-	}
-
 	prev_status = call->status;
-	DBG("Call %s changed from %s to %s", call_path,
+	DBG("Call %s changed from %s to %s", call->object_path,
 		call_status_str[prev_status], call_status_str[status]);
 
 	if (prev_status == status) {
@@ -1132,6 +1110,35 @@ static void handle_call_status(DBusMessage *msg, const char *call_path)
 	}
 }
 
+static void handle_call_status(DBusMessage *msg, const char *call_path)
+{
+	struct csd_call *call;
+	dbus_uint32_t status, cause_type, cause;
+
+	if (!dbus_message_get_args(msg, NULL,
+					DBUS_TYPE_UINT32, &status,
+					DBUS_TYPE_UINT32, &cause_type,
+					DBUS_TYPE_UINT32, &cause,
+					DBUS_TYPE_INVALID)) {
+		error("Unexpected paramters in Instance.CallStatus() signal");
+		return;
+	}
+
+	call = find_call(call_path);
+	if (!call) {
+		error("Didn't find any matching call object for %s",
+				call_path);
+		return;
+	}
+
+	if (status > 16) {
+		error("Invalid call status %u", status);
+		return;
+	}
+
+	call_set_status(call, status);
+}
+
 static void handle_conference(DBusMessage *msg, gboolean joined)
 {
 	const char *path;
@@ -1470,13 +1477,12 @@ static void parse_call_list(DBusMessageIter *iter)
 		if (!call) {
 			call = g_new0(struct csd_call, 1);
 			call->object_path = g_strdup(object_path);
-			call->status = (int) status;
 			calls = g_slist_append(calls, call);
 			DBG("telephony-maemo6: new csd call instance at %s",
 								object_path);
 		}
 
-		if (call->status == CSD_CALL_STATUS_IDLE)
+		if (status == CSD_CALL_STATUS_IDLE)
 			continue;
 
 		/* CSD gives incorrect call_hold property sometimes */
@@ -1493,6 +1499,9 @@ static void parse_call_list(DBusMessageIter *iter)
 		g_free(call->number);
 		call->number = g_strdup(number);
 
+		/* Update indicators */
+		call_set_status(call, status);
+
 	} while (dbus_message_iter_next(iter));
 }
 
-- 
1.7.1

diff --git a/audio/telephony-maemo6.c b/audio/telephony-maemo6.c
index dfa06d9..bf1e0c4 100644
--- a/audio/telephony-maemo6.c
+++ b/audio/telephony-maemo6.c
@@ -2028,6 +2028,9 @@ void telephony_exit(void)
 	g_free(last_dialed_number);
 	last_dialed_number = NULL;
 
+	g_slist_free(active_calls);
+	active_calls = NULL;
+
 	g_slist_foreach(calls, (GFunc) csd_call_free, NULL);
 	g_slist_free(calls);
 	calls = NULL;
